<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta charset='utf-8'>
        <title>Literate Code &mdash; a Responsive Prototype for a Programming Essay</title>
        <link href='stylesheets/css/screen.css' media='screen' rel='stylesheet'>
        <link href="google-code-prettify/src/prettify.css" type="text/css" rel="stylesheet" />
        <script type="text/javascript" src="google-code-prettify/src/prettify.js"></script>
    </head>
    <body onload="prettyPrint()">
        <!--<div class="debug"><p></p></div>-->
    <header>
        <h1>
            Literate Code 
            <span>&mdash; a responsive prototype for a programming essay</span>
        </h1>
        <div class="row group wrapper">
            <article id ="intro" class="col12 prose">
                <p>
                    <span>The Computer Science curriculum</span> is a curious thing. On one hand, certain things remain unchanged:
                    the von Neumnann architecture, automata theory, compilation & interpretation, fundamental data
                    structures and algorithms, etc. These are the foundations.
                </p>
                <p>
                    On the other hand, the discipline of software engineering is dynamic and evolving.
                    A lot of it is happening in Open Source; it is discussed in the developer blogosphere;
                    and often documented online. This makes it a tough field to capture in a static, "tetxbook"
                    curriculum.
                </p>
                <blockquote>
                    <p>
                        The practitioner of literate programming can be regarded as an essayist, whose main concern
                        is with exposition and excellence of style.
                    </p>
                    <footer>&mdash;Donald Knuth in <a href="http://www-cs-faculty.stanford.edu/~uno/lp.html">Literate Programming</a></footer>
                </blockquote>
                <p>
                    Who is better qualified, then, to teach software engineering than the experienced programmer / developer
                    working right in the trenches? And, which channel is more natural for the dissemination of his knowledge
                    than the web?
                </p>
                <p>
                    Self&ndash;publishing of such expert content has never been easier. But the presentation, reader&ndash;friendliness,
                    and consumability of it deserve special attention. Packaging and design play a great role towards increasing
                    the accessibility of content.
                </p>
                <p>
                    <strong>Literate Code</strong>, the demo for this page, is a prototype of a possible design approach (open source and
                    <a href="https://github.com/abbottjam/literate-code">hosted on GitHub</a>). The ingredients?
                </p>
                <ul>
                    <li>
                        A static adaptive layout (inspired by the brilliant <a href="http://framelessgrid.com/">Frameless Grid by Joni Korpi)</a>;
                    </li>
                    <li>Optimal use of screen real estate, whether in Desktop, Tablet, or Mobile modes;</li>
                    <li>
                        Syntax highlighting through <a href="http://code.google.com/p/google-code-prettify/">google&ndash;code&ndash;prettify;</a>
                    </li>
                    <li>Color and typography defaults to maximize readability.</li>
                </ul>
                <p>
                    It's very much a "minimum viable product"; something to prove the concept. Got feedback? 
                    <a href="https://twitter.com/#!/abbottjam">I'd love to hear it</a>.
                </p>
                <p>
                    <strong>PS.</strong> The essay used for the demo below is a modified version of 
                    <a href="http://jamesabbottdd.com/programming/problem-solving-with-automata-based-programming">
                       an article originally written in 2011</a>. In programmer maturity years, that's about a decade.
                    Still, as a demo it does the job.
                    <span></span>
                </p>
            </article>
        </div>
    </header>
    
    <div role="main" class="wrapper">
        <article role="main" class="group row">
            <header class="col7 text">
                <h1><a name="top"></a>Problem&ndash;solving with Automata&ndash;Based Programming</h1>
                <div class="toc group">
                    <h2>Contents</h2>
                    <ul>
                        <li><a href="#motivation">Motivation for a character-based text processing script</a><em>/</em></li>
                        <li><a href="#maybe">Maybe a solution</a><em>/</em></li>
                        <li><a href="#Automata&ndash;Based">Automata&ndash;based solution</a><em>/</em></li>
                        <li><a href="#characteristics">Characteristics and advantages</a><em>/</em></li>
                        <li><a href="#resources">Relevant resources</a></li>
                    </ul>
                </div>
            </header>
            <div class="col7 text">
                <p>
                    Recently when working with CSS, I wanted to automate some deployment-related tasks, such as: combining a
                    number of CSS files into one; fixing image paths from production to deployment values; and stripping out
                    the comments from the production&ndash;ready file. So I wrote a script that I that I now call every time I need
                    to deploy CSS, whether when adding a new design or modifying an existing one.
                </p>
                <p>
                    While working on the comment&ndash;stripping part of the script (which was the meat of the task) I researched a
                    style of programming called Automata&ndash;Based Programming. I liked it so much that I'll discuss its
                    characteristics and merits here.
                </p>
                <h2>Motivation for a character&ndash;based text processing script<a name="motivation">
                    </a><span class="ttp"><a href="#top"></a></span>
                </h2>
                <p>
                    I wanted to achieve the de&ndash;commenting in a single pass, producing an output CSS file without modifying the input
                    file. (I also didn't want to resort to using regular expressions immediately, wanting to develop a more fine&ndash;grained,
                    character&ndash;based approach. My assumption was that a large file should be processed as a character stream, rather than a
                    large string).
                </p>

                <h2>Maybe a solution<a name="maybe"></a><span class="ttp"><a href="#top"></a></span></h2>
                <p>
                    The first thing that came to mind was the naive, character&ndash;for&ndash;character procedural approach,
                    something along the lines of, in pseudocode:
                </p>
            </div>

            <div class="col8 code">
                <pre><code>
inside_comment = false
while not end_of_file do
  one = getchar
  two = getchar
  if not inside_comment and one =='/' and two =='*'
    inside_comment = true
  else
    if not inside_comment print one, two
  if inside_comment
    if one =='*' and two =='/'
      inside_comment = false
    else
      one = getchar
      two = getchar
      if one =='*' and two =='/'
        inside_comment = false
                    </code></pre>
            </div>

            <div class="col7 text">
                <p>
                    This was bound to build up to a crescendo of nested "if"s and "while"s. There is massive duplication with calls
                    to <code>getchar</code>, as well as referencing and setting <code>inside_comment</code>. More importantly, this code builds on
                    the assumption that the number of characters preceding the start of a comment is divisible by two. If that number 
                    isn't even, the solution will fail and it would take additional conditional branching to make it work. All in all, a brittle,
                    hardly readable solution with to not&ndash;so&ndash;subtle logical flaws.
                </p>
                <p>
                    Next, I considered using a string library to delegate pattern&ndash;matching to. I had seen the <code>StringScanner</code>
                    class being used for parsing JSON, so I thought about using <code>StringScanner#scan</code> to move through
                    the string finding comments. However, all that ultimately boiled down to was using a library to find occurrences of just two
                    patterns: <code>/*</code> and <code>*/</code>. It was all about these two combinations of these two characters. 
                    No nested structures, no recursion, no well&ndash;formed language constructs. No grammar to validate against. This realization
                    made using a library look rather redundant.
                </p>
                <blockquote>
                    <p>
                        Pragmaitic Programmers manipulate text the same way woodworkers shape wood.
                    </p>
                    <footer>
                        &mdash;Andy Hunt &amp; Dave Thomas in
                        <a href="http://pragprog.com/the-pragmatic-programmer">The Pragmatic Programmer</a>
                    </footer>
                </blockquote>
                <p>
                    So I decided to develop a raw, from&ndash;scratch approach &mdash; processing the CSS character&ndash;by&ndash;character.
                    I visualized characters being pumped from the source file to the target file. Obviously, that alone wasn't enough &mdash;
                    the characters would need to step through some sort of transformation phase. How could the de&ndash;commenting function
                    be formulated? What if there was an intermediate destination for these characters &mdash; one that would act like a valve,
                    letting characters through if they were'nt inside a comment and closing when they were?
                </p>
                <p>
                    This "valve" data structure would accumulate characters when a comment was entered. When it would detect the end of that
                    comment, the accumulated characters would be cleared (meaning, the comment would be discarded). This process would go on
                    until end of file was reached.
                </p>

                <h2>Automata&ndash;Based solution<a name="Automata&ndash;Based"></a><span class="ttp"><a href="#top"></a></span></h2>
                <p>
                    Implementation&ndash;wise, this would be a queue with some helper methods for analyzing the top two characters. The Ruby
                    <code>Array</code> class, with it's <code>#shift</code> method, provided a foundation for that data structure.
                </p>
                <p>
                    This approach opened the door for completely linearizing the program &mdash; only one "while" loop (the outermost loop
                    that reads in characters as long as there are more) was needed. That, it turned out, is one of the characteristics
                    of Automata&ndash;Based Programming: a flat, "un&ndash;tangled" program without a lot of indentation levels and just one 
                    loop: the input&ndash;reading one.
                </p>
            </div>
            <div class="col8 code">
                <pre class="prettyprint"><code>
def process(char)
    add(char)
    @comment = true if comment_start
    @comment = false if comment_end
    c = filter
    c unless c.nil?
end
                </code></pre>
            </div>

            <div class="col7 text">
                <p>
                    With each step of the program (which adds a character to the data structure) I check for a presence of a comment based
                    on what the top 2 characters on the queue are (the values I'm looking for are <code>/*</code> and <code>*/</code>).
                    An boolean flag (the <code>@comment</code> variable) is then set accordingly.
                </p>
                <p>
                    Based on a subset of all possible values of these three factors (<code>comment_start</code>, <code>comment_end</code>,
                    and <code>@comment</code>), one of the following three steps is executed:
                </p>
                <ul>
                    <li>Dequeue the first character to the output (we have just entered a comment), set flag as true;</li>
                    <li>Clear the stack (we have reached the end of a comment), set flag as false;</li>
                    <li>Dequeue the first character to the output (no comment in sight).</li>
                </ul>
            </div>

            <div class="col8 code">
                <pre class="prettyprint"><code>
def filter
    return get_first if ready and comment_start #["c", "/", "*"] - pop "c"
    clear if comment_end #["/", "*", "a", "b", "c", "*", "/"]
    get_first if ready and !comment #["a", "b", "c"] or ["b", "c", "/"]
end
                    </code></pre>
            </div>

            <div class="col7 text">
                <p>
                    Here, we have another characteristic of Automata&ndash;Based Programming: with each step of the program (here, it is adding a
                    character to the queue) we query and / or modify the the program's "state". ("State" is the value of a set of variables
                    at a particular step of the program). When the program continues, it a number of branches are possible. The branch that
                    that is associated with each state will be executed. This has the effect of "flattening out"
                    the program's logical branches &mdash; they become conditional statements that often all appear at one level. Almost assembly
                    language&ndash;like.
                </p>

                <p>
                    (<a href="https://github.com/abbottjam/rapidui/blob/master/css/css_manager/css_manager.rb"
                        title="css_manager.rb on GitHub">Here is the complete program on GitHub</a>).
                </p>

                <h2>Characteristics and advantages<a name="characteristics"></a><span class="ttp"><a href="#top"></a></span></h2>
                <p>
                    I find that Automata&ndash;Based Programming is very useful, because it allows me to create programs around
                    solid logical structures. Because ABP is based om logical anchors as to what is happening at each step, it
                    allows me to write programs that are easy to reason about. For example, the following statements about the
                    helper data structure can be formalized:
                </p>
                <ul>
                    <li><strong>A precondition for querying the state of the queue:</strong> The queue must contain at least two characters.</li>
                    <li><strong>A precondition for removing the first character from the queue:</strong> The queue must contain at least
                        three characters.</li>
                    <li><strong>An invariant for the queue:</strong> When we are not inside a comment the queue is never longer than 3
                        characters.</li>
                </ul>
                <p>
                    ABP&ndash;style programs are also easy to visualize as their underlying theoretical model: automata.
                    Specifically, the visualization of the queue acting as a physical valve was the crucial step in solving the problem.
                    All that remained was to write the program.
                </p>
                <p>
                    Programs created in this style are easy to read, a pleasure to write, and are robust in structure, as they
                    build on a formal logical model (A Finite State Machine, or FSM). ABP&ndash;style programs allow one to program for
                    correctness and therefore, testability. Beyond clean code, there are other reasons to be proficient in this
                    coding paradigm. Let's list a few of its applications:
                </p>
                <p>
                    <strong>Advanced text processing.</strong> The example in this article is very simple, but Finite State Machines are effective
                    at processing text input of varying complexity and structure, from markup to Turing&ndash;complete languages. An example
                    of this is the part of browser code called the tokenization algorithm. Its input is an HTML string and the output is a token
                    representation of that string.
                    It's <a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_tokenization_algorithm">
                        expressed as a state machine</a>.
                </p>
                <p>
                    <strong>The logic behind Graphical User Interfaces.</strong> Because user interfaces are stateful, FSMs are very 
                    well&ndash;suited for modeling them in States, Events, and Transitions. For a modern example, see Alex MacCaw's
                    Super.js &mdash; <a href="https://github.com/maccman/super.js" title="Super.js at GitHub">a modular, jQuery-based JavaScript
                    library for building RIAs</a>.
                </p>
                <p>
                    <strong>Making Object&ndash;Oriented better by encapsulating and controlling "state".</strong> In OO,
                    objects have state at runtime. State (defined as the total value of an object's instance variables) is one&ndash;third
                    of the OO trinity: <em>state, behavior, &amp; identity</em>.
                </p>
                <p>
                    OO state, however, is less rigorously defined than FSM state, and is therefore easier to get wrong.
                    (See Rich Hickey's <a href="http://clojure.org/state" title="Rich Hickey on State">article on state</a>).
                    Especially in large OO programs, state often acquires somewhat of a life of its own, causing side effects 
                    and unexpected behavior. Constructing OO programs that implement state in accordance with the state machine 
                    model is useful in making stateful programs more manageable and predictable.
                </p>
                
                <h2>Relevant resources<a name="resources"></a><span class="ttp"><a href="#top"></a></span></h2>
                <p>Some resources on state&ndash;based computation and Automata&ndash;Based Programming:</p>

                <p>
                    The Wikipedia has a fantastic article with an example of how to transform a character &mdash; processing program from
                    imperative style into ABP style: <a href="http://en.wikipedia.org/wiki/Automata&ndash;Based_programming"
                                                        title="Automata&ndash;Based Programming on Wikipedia">Automata&ndash;Based Programming</a>.
                </p>

                <p>
                    In <a href="http://www.amazon.com/Programming-Pearls-2nd-Jon-Bentley/dp/0201657880" title="Programming Pearls">
                    Programming Pearls</a>, Jon Bentley describes the evolution of a program to find the maximal&ndash;value subarray in an array
                    of integers. The final solution combines scanning and state&ndash;saving to achieve a very short and fast program.
                    Although it doesn't have explicit "State" classes or transitions, it works by querying and (re)setting state
                    at each step; I like to think of it as the prototypal ABP&ndash;style program.
                    <span></span>
                </p>
                <footer>
                    <!-- date, author, etc-->
                </footer>
        </article>
    </div>
</div>
<footer>
    <a href="https://github.com/abbottjam/literate-code">
        <img src="./images/octocat.png" alt="Literate Code files on GitHub" />
    </a>
    <p role="contentinfo">
        Hand&ndash;crafted <em>for the</em> self&ndash;publishing developer expert.
        <small><em>2012</em> &copy; Literate Code <em>by</em> James Abbott.</small>
    </p>
</footer>

</body>
</html>